--- xmms2-0.2DrJekyll/src/plugins/avformat/avformat.c.orig	2007-05-20 17:55:40.000000000 +0200
+++ xmms2-0.2DrJekyll/src/plugins/avformat/avformat.c	2023-05-17 17:39:28.342596542 +0200
@@ -24,7 +24,7 @@
 #include <glib.h>
 
 #undef ABS
-#include "avformat.h"
+#include <libavformat/avformat.h>
 
 #define AVFORMAT_BUFFER_SIZE 4096
 
@@ -33,7 +33,7 @@ typedef struct {
 
 	AVFormatContext *fmtctx;
 	AVCodecContext *codecctx;
-	offset_t offset;
+	int64_t offset;
 
 	guchar buffer[AVFORMAT_BUFFER_SIZE];
 	guint buffer_size;
@@ -72,7 +72,7 @@ static void xmms_asf_metahack (xmms_xfor
 
 int xmms_avformat_read_callback (void *user_data, uint8_t *buffer,
                                  int length);
-offset_t xmms_avformat_seek_callback (void *user_data, offset_t offset, int whence);
+int64_t xmms_avformat_seek_callback (void *user_data, int64_t offset, int whence);
 
 /*
  * Plugin header
@@ -124,7 +124,7 @@ xmms_avformat_destroy (xmms_xform_t *xfo
 	data = xmms_xform_private_data_get (xform);
 	g_return_if_fail (data);
 
-	av_close_input_file (data->fmtctx);
+	avformat_close_input (&data->fmtctx);
 
 	g_string_free (data->outbuf, TRUE);
 	g_free (data);
@@ -135,7 +135,7 @@ xmms_avformat_init (xmms_xform_t *xform)
 {
 	xmms_avformat_data_t *data;
 	AVInputFormat *format;
-	ByteIOContext byteio;
+	AVIOContext *byteio;
 	AVCodec *codec;
 	const gchar *mimetype;
 	gint temp;
@@ -172,13 +172,18 @@ xmms_avformat_init (xmms_xform_t *xform)
 	}
 
 	format->flags |= AVFMT_NOFILE;
-	if ((temp = init_put_byte (&byteio, data->buffer, data->buffer_size, 0,
+	if ((byteio = avio_alloc_context (data->buffer, data->buffer_size, 0,
 	                           xform, xmms_avformat_read_callback, NULL,
-	                           xmms_avformat_seek_callback)) < 0) {
-		XMMS_DBG ("Could not initialize ByteIOContext structure: %d", temp);
+	                           xmms_avformat_seek_callback)) == NULL) {
+		XMMS_DBG ("Could not initialize AVIOContext structure");
 		goto err;
 	}
-	if ((temp = av_open_input_stream (&data->fmtctx, &byteio, "", format,
+	if ((data->fmtctx = avformat_alloc_context()) == NULL) {
+		XMMS_DBG ("Could not initialize AVFormatContext structure");
+		goto err;
+	}
+	data->fmtctx->pb = byteio;
+	if ((temp = avformat_open_input (&data->fmtctx, "", format,
 	                                  NULL)) < 0) {
 		XMMS_DBG ("Could not open input stream for ASF format: %d", temp);
 		goto err;
@@ -230,7 +235,7 @@ xmms_avformat_init (xmms_xform_t *xform)
 
 err:
 	if (data->fmtctx) {
-		av_close_input_file (data->fmtctx);
+		avformat_close_input (data->fmtctx);
 	}
 	g_string_free (data->outbuf, TRUE);
 	g_free (data);
@@ -501,8 +506,8 @@ xmms_avformat_read_callback (void *user_
 	return ret;
 }
 
-offset_t
-xmms_avformat_seek_callback (void *user_data, offset_t offset, int whence)
+int64_t
+xmms_avformat_seek_callback (void *user_data, int64_t offset, int whence)
 {
 	xmms_xform_t *xform;
 	xmms_avformat_data_t *data;
@@ -552,7 +557,7 @@ xmms_avformat_get_track (AVFormatContext
 	for (wma_idx = 0; wma_idx < fmtctx->nb_streams; wma_idx++) {
 		codec = fmtctx->streams[wma_idx]->codec;
 
-		if (codec->codec_type == CODEC_TYPE_AUDIO) {
+		if (codec->codec_type == AVMEDIA_TYPE_AUDIO) {
 			break;
 		}
 	}
--- xmms2-0.2DrJekyll/src/plugins/avcodec/avcodec.c.orig	2007-05-20 17:55:40.000000000 +0200
+++ xmms2-0.2DrJekyll/src/plugins/avcodec/avcodec.c	2023-05-18 18:38:52.423864232 +0200
@@ -24,7 +24,7 @@
 #include <glib.h>
 
 #undef ABS
-#include "avcodec.h"
+#include <libavcodec/avcodec.h>
 
 #define AVCODEC_BUFFER_SIZE 16384
 
@@ -134,7 +134,7 @@ xmms_avcodec_init (xmms_xform_t *xform)
 		goto err;
 	}
 
-	if (codec->type != CODEC_TYPE_AUDIO) {
+	if (codec->type != AVMEDIA_TYPE_AUDIO) {
 		XMMS_DBG ("Codec '%s' found but its type is not audio", data->codec_id);
 		goto err;
 	}
@@ -155,9 +155,9 @@ xmms_avcodec_init (xmms_xform_t *xform)
 	data->codecctx->extradata_size = data->extradata_size;
 
 	/* FIXME: this is for ALAC but can be a different value */
-	data->codecctx->bits_per_sample = 16;
+	data->codecctx->bits_per_raw_sample = 16;
 
-	if (avcodec_open (data->codecctx, codec) < 0) {
+	if (avcodec_open2 (data->codecctx, codec, NULL) < 0) {
 		XMMS_DBG ("Opening decoder '%s' failed", codec->name);
 		goto err;
 	} else {
@@ -206,7 +206,6 @@ xmms_avcodec_read (xmms_xform_t *xform,
                    xmms_error_t *error)
 {
 	xmms_avcodec_data_t *data;
-	char outbuf[AVCODEC_MAX_AUDIO_FRAME_SIZE];
 	gint outbufsize, bytes_read = 0;
 	guint size;
 
@@ -215,6 +214,11 @@ xmms_avcodec_read (xmms_xform_t *xform,
 
 	size = MIN (data->outbuf->len, len);
 	while (size == 0) {
+		int got_frame = 0;
+		AVFrame *frame;
+		AVPacket packet;
+		av_init_packet (&packet);
+
 		if (data->buffer_length == 0) {
 			bytes_read = xmms_xform_read (xform,
 			                              (gchar *) data->buffer,
@@ -232,11 +236,19 @@ xmms_avcodec_read (xmms_xform_t *xform,
 			data->buffer_length += bytes_read;
 		}
 
-		bytes_read = avcodec_decode_audio (data->codecctx, (short *) outbuf,
-		                                   &outbufsize, data->buffer,
-		                                   data->buffer_length);
+		packet.data = data->buffer;
+		packet.size = data->buffer_length;
+
+		frame = av_frame_alloc();
+		if (frame == NULL) {
+			XMMS_DBG ("AVFrame allocation failed");
+			return -1;
+		}
+
+		bytes_read = avcodec_decode_audio4 (data->codecctx, frame, &got_frame, &packet);
 
 		if (bytes_read < 0) {
+			av_frame_free(&frame);
 			XMMS_DBG ("Error decoding data!");
 			return -1;
 		} else if (bytes_read == 0) {
@@ -246,9 +258,11 @@ xmms_avcodec_read (xmms_xform_t *xform,
 
 		data->buffer_length -= bytes_read;
 
-		if (outbufsize > 0) {
-			g_string_append_len (data->outbuf, outbuf, outbufsize);
+		if (got_frame) {
+			outbufsize = av_samples_get_buffer_size(NULL, data->codecctx->channels, frame->nb_samples, data->codecctx->sample_fmt, 1);
+			g_string_append_len (data->outbuf, frame->data[0], outbufsize);
 		}
+		av_frame_free(&frame);
 
 		size = MIN (data->outbuf->len, len);
 	}
