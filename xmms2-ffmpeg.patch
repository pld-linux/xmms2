--- xmms2-0.6DrMattDestruction/src/plugins/avcodec/avcodec.c.orig	2009-04-21 19:51:11.000000000 +0200
+++ xmms2-0.6DrMattDestruction/src/plugins/avcodec/avcodec.c	2023-05-22 09:34:51.481410306 +0200
@@ -160,7 +160,7 @@ xmms_avcodec_init (xmms_xform_t *xform)
 		goto err;
 	}
 
-	if (codec->type != CODEC_TYPE_AUDIO) {
+	if (codec->type != AVMEDIA_TYPE_AUDIO) {
 		XMMS_DBG ("Codec '%s' found but its type is not audio", data->codec_id);
 		goto err;
 	}
@@ -219,7 +219,7 @@ xmms_avcodec_init (xmms_xform_t *xform)
 	data->codecctx->extradata = data->extradata;
 	data->codecctx->extradata_size = data->extradata_size;
 
-	if (avcodec_open (data->codecctx, codec) < 0) {
+	if (avcodec_open2 (data->codecctx, codec, NULL) < 0) {
 		XMMS_DBG ("Opening decoder '%s' failed", codec->name);
 		goto err;
 	} else {
@@ -270,7 +270,6 @@ xmms_avcodec_read (xmms_xform_t *xform,
                    xmms_error_t *error)
 {
 	xmms_avcodec_data_t *data;
-	char outbuf[AVCODEC_MAX_AUDIO_FRAME_SIZE];
 	gint outbufsize, bytes_read = 0;
 	guint size;
 
@@ -279,6 +278,11 @@ xmms_avcodec_read (xmms_xform_t *xform,
 
 	size = MIN (data->outbuf->len, len);
 	while (size == 0) {
+		int got_frame = 0;
+		AVFrame *frame;
+		AVPacket packet;
+		av_init_packet (&packet);
+
 		if (data->buffer_length == 0) {
 			gint read_total;
 
@@ -332,12 +336,19 @@ xmms_avcodec_read (xmms_xform_t *xform,
 			data->buffer_length = read_total;
 		}
 
-		outbufsize = sizeof (outbuf);
-		bytes_read = avcodec_decode_audio2 (data->codecctx, (short *) outbuf,
-		                                    &outbufsize, data->buffer_pos,
-		                                    data->buffer_length);
+		packet.data = data->buffer;
+		packet.size = data->buffer_length;
+
+		frame = av_frame_alloc();
+		if (frame == NULL) {
+			XMMS_DBG ("AVFrame allocation failed");
+			return -1;
+		}
+
+		bytes_read = avcodec_decode_audio4 (data->codecctx, frame, &got_frame, &packet);
 
 		if (bytes_read < 0 || bytes_read > data->buffer_length) {
+			av_frame_free(&frame);
 			XMMS_DBG ("Error decoding data!");
 			return -1;
 		}
@@ -345,9 +356,11 @@ xmms_avcodec_read (xmms_xform_t *xform,
 		data->buffer_pos += bytes_read;
 		data->buffer_length -= bytes_read;
 
-		if (outbufsize > 0) {
-			g_string_append_len (data->outbuf, outbuf, outbufsize);
+		if (got_frame) {
+			outbufsize = av_samples_get_buffer_size(NULL, data->codecctx->channels, frame->nb_samples, data->codecctx->sample_fmt, 1);
+			g_string_append_len (data->outbuf, frame->data[0], outbufsize);
 		}
+		av_frame_free(&frame);
 
 		size = MIN (data->outbuf->len, len);
 	}
@@ -375,7 +375,6 @@ static gint64
 xmms_avcodec_seek (xmms_xform_t *xform, gint64 samples, xmms_xform_seek_mode_t whence, xmms_error_t *err)
 {
 	xmms_avcodec_data_t *data;
-	char outbuf[AVCODEC_MAX_AUDIO_FRAME_SIZE];
 	gint outbufsize, bytes_read = 0;
 	gint64 ret = -1;
 
@@ -395,10 +394,22 @@ xmms_avcodec_seek (xmms_xform_t *xform,
 	/* The buggy ape decoder doesn't flush buffers, so we need to finish decoding
 	 * the frame before seeking to avoid segfaults... this hack sucks */
 	while (data->buffer_length > 0) {
-		outbufsize = sizeof (outbuf);
-		bytes_read = avcodec_decode_audio2 (data->codecctx, (short *) outbuf,
-		                                    &outbufsize, data->buffer,
-		                                    data->buffer_length);
+		int got_frame = 0;
+		AVFrame *frame;
+		AVPacket packet;
+		av_init_packet (&packet);
+
+		packet.data = data->buffer;
+		packet.size = data->buffer_length;
+
+		frame = av_frame_alloc();
+		if (frame == NULL) {
+			XMMS_DBG ("AVFrame allocation failed");
+			return -1;
+		}
+
+		bytes_read = avcodec_decode_audio4 (data->codecctx, frame, &got_frame, &packet);
+		av_frame_free(&frame);
 
 		if (bytes_read < 0 || bytes_read > data->buffer_length) {
 			XMMS_DBG ("Error decoding data!");
